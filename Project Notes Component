import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { 
  Sheet, 
  SheetContent, 
  SheetDescription, 
  SheetHeader, 
  SheetTitle, 
  SheetTrigger,
  SheetFooter,
  SheetClose
} from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Note } from "@shared/schema";
import { NoteWithRelations } from "@/lib/types";
import { format } from "date-fns";
import { Loader2, MessageCircle, Save, Trash2, Plus, X } from "lucide-react";
import { apiRequest } from "@/lib/queryClient";
import { queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";

interface ProjectNotesProps {
  projectId: number;
  projectTitle: string;
}

export function ProjectNotes({ projectId, projectTitle }: ProjectNotesProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [newNote, setNewNote] = useState("");
  const [isAddingNote, setIsAddingNote] = useState(false);
  const [editingNoteId, setEditingNoteId] = useState<number | null>(null);
  const [editingNoteContent, setEditingNoteContent] = useState("");
  const { toast } = useToast();

  // Fetch notes for the project
  const { 
    data: notes = [], 
    isLoading: notesLoading 
  } = useQuery<Note[]>({
    queryKey: ["/api/projects", projectId, "notes"],
    queryFn: async ({ queryKey }) => {
      if (!isOpen) return [];
      const response = await fetch(`/api/projects/${queryKey[1]}/notes`);
      if (!response.ok) {
        throw new Error("Failed to fetch notes");
      }
      return response.json();
    },
    enabled: isOpen
  });

  // Format notes with additional display fields
  const formattedNotes: NoteWithRelations[] = notes.map(note => {
    return {
      ...note,
      formattedCreatedAt: format(new Date(note.createdAt), "MMMM d, yyyy 'at' h:mm a")
    };
  });

  // Add note mutation
  const addNoteMutation = useMutation({
    mutationFn: async (content: string) => {
      const response = await apiRequest(
        "POST", 
        "/api/notes", 
        { projectId, content }
      );
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ 
        queryKey: ["/api/projects", projectId, "notes"] 
      });
      setNewNote("");
      setIsAddingNote(false);
      toast({
        title: "Note added",
        description: "Your note has been added successfully."
      });
    },
    onError: (error) => {
      toast({
        title: "Failed to add note",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    }
  });

  // Edit note mutation
  const editNoteMutation = useMutation({
    mutationFn: async ({ id, content }: { id: number; content: string }) => {
      const response = await apiRequest(
        "PATCH", 
        `/api/notes/${id}`, 
        { content }
      );
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ 
        queryKey: ["/api/projects", projectId, "notes"] 
      });
      setEditingNoteId(null);
      setEditingNoteContent("");
      toast({
        title: "Note updated",
        description: "Your note has been updated successfully."
      });
    },
    onError: (error) => {
      toast({
        title: "Failed to update note",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    }
  });

  // Delete note mutation
  const deleteNoteMutation = useMutation({
    mutationFn: async (id: number) => {
      await apiRequest("DELETE", `/api/notes/${id}`);
      return id;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ 
        queryKey: ["/api/projects", projectId, "notes"] 
      });
      toast({
        title: "Note deleted",
        description: "Your note has been deleted successfully."
      });
    },
    onError: (error) => {
      toast({
        title: "Failed to delete note",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    }
  });

  const handleAddNote = () => {
    if (newNote.trim()) {
      addNoteMutation.mutate(newNote.trim());
    }
  };

  const handleEditNote = (id: number, content: string) => {
    setEditingNoteId(id);
    setEditingNoteContent(content);
  };

  const handleSaveEdit = () => {
    if (editingNoteId && editingNoteContent.trim()) {
      editNoteMutation.mutate({ 
        id: editingNoteId, 
        content: editingNoteContent.trim() 
      });
    }
  };

  const handleDeleteNote = (id: number) => {
    deleteNoteMutation.mutate(id);
  };

  return (
    <Sheet open={isOpen} onOpenChange={setIsOpen}>
      <SheetTrigger asChild>
        <Button variant="outline" size="sm" className="flex items-center">
          <MessageCircle className="h-4 w-4 mr-2" />
          Notes
        </Button>
      </SheetTrigger>
      <SheetContent className="sm:max-w-md">
        <SheetHeader>
          <SheetTitle>Notes for {projectTitle}</SheetTitle>
          <SheetDescription>
            View and manage notes for this project
          </SheetDescription>
        </SheetHeader>
        
        <div className="mt-6 space-y-4">
          {/* Add note button */}
          {!isAddingNote && (
            <Button 
              variant="outline" 
              onClick={() => setIsAddingNote(true)}
              className="w-full"
            >
              <Plus className="h-4 w-4 mr-2" />
              Add Note
            </Button>
          )}
          
          {/* Add note form */}
          {isAddingNote && (
            <div className="space-y-2 border rounded-md p-3">
              <Textarea
                placeholder="Enter your note..."
                value={newNote}
                onChange={(e) => setNewNote(e.target.value)}
                className="min-h-[100px]"
              />
              <div className="flex justify-end space-x-2">
                <Button 
                  variant="outline" 
                  size="sm" 
                  onClick={() => {
                    setIsAddingNote(false);
                    setNewNote("");
                  }}
                  disabled={addNoteMutation.isPending}
                >
                  <X className="h-4 w-4 mr-1" />
                  Cancel
                </Button>
                <Button 
                  size="sm" 
                  onClick={handleAddNote}
                  disabled={!newNote.trim() || addNoteMutation.isPending}
                >
                  {addNoteMutation.isPending ? (
                    <>
                      <Loader2 className="h-4 w-4 animate-spin mr-1" />
                      Saving...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-1" />
                      Save
                    </>
                  )}
                </Button>
              </div>
            </div>
          )}
          
          {/* Loading state */}
          {notesLoading && (
            <div className="text-center py-6">
              <Loader2 className="h-8 w-8 animate-spin mx-auto text-muted-foreground" />
              <p className="mt-2 text-sm text-muted-foreground">Loading notes...</p>
            </div>
          )}
          
          {/* Empty state */}
          {!notesLoading && formattedNotes.length === 0 && !isAddingNote && (
            <div className="text-center py-8">
              <MessageCircle className="h-10 w-10 mx-auto text-muted-foreground opacity-20" />
              <p className="mt-2 text-sm text-muted-foreground">No notes yet. Add your first note to track progress.</p>
            </div>
          )}
          
          {/* Notes list */}
          {!notesLoading && formattedNotes.length > 0 && (
            <div className="space-y-4">
              {formattedNotes.map((note) => (
                <div key={note.id} className="border rounded-md p-3">
                  {editingNoteId === note.id ? (
                    <div className="space-y-2">
                      <Textarea
                        value={editingNoteContent}
                        onChange={(e) => setEditingNoteContent(e.target.value)}
                        className="min-h-[100px]"
                      />
                      <div className="flex justify-end space-x-2">
                        <Button 
                          variant="outline" 
                          size="sm" 
                          onClick={() => {
                            setEditingNoteId(null);
                            setEditingNoteContent("");
                          }}
                          disabled={editNoteMutation.isPending}
                        >
                          <X className="h-4 w-4 mr-1" />
                          Cancel
                        </Button>
                        <Button 
                          size="sm" 
                          onClick={handleSaveEdit}
                          disabled={!editingNoteContent.trim() || editNoteMutation.isPending}
                        >
                          {editNoteMutation.isPending ? (
                            <>
                              <Loader2 className="h-4 w-4 animate-spin mr-1" />
                              Saving...
                            </>
                          ) : (
                            <>
                              <Save className="h-4 w-4 mr-1" />
                              Save
                            </>
                          )}
                        </Button>
                      </div>
                    </div>
                  ) : (
                    <>
                      <p className="text-sm whitespace-pre-wrap">{note.content}</p>
                      <div className="flex justify-between items-center mt-2 pt-2 border-t text-xs text-muted-foreground">
                        <span>{note.formattedCreatedAt}</span>
                        <div className="flex space-x-1">
                          <Button 
                            variant="ghost" 
                            size="icon" 
                            className="h-6 w-6" 
                            onClick={() => handleEditNote(note.id, note.content)}
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                              <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                              <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                            </svg>
                          </Button>
                          <Button 
                            variant="ghost" 
                            size="icon" 
                            className="h-6 w-6 text-red-500 hover:text-red-600 hover:bg-red-50"
                            onClick={() => handleDeleteNote(note.id)}
                          >
                            <Trash2 className="h-3.5 w-3.5" />
                          </Button>
                        </div>
                      </div>
                    </>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
        
        <SheetFooter className="mt-6">
          <SheetClose asChild>
            <Button variant="outline">Close</Button>
          </SheetClose>
        </SheetFooter>
      </SheetContent>
    </Sheet>
  );
}
