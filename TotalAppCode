import { pgTable, serial, text, timestamp, boolean } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Users table
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull(),
  password: text("password").notNull(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
});

// Projects table
export const projects = pgTable("projects", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  tagName: text("tag_name"),
  tagColor: text("tag_color"),
  priority: text("priority").default("medium"),
  completed: boolean("completed").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertProjectSchema = createInsertSchema(projects).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Notes table
export const notes = pgTable("notes", {
  id: serial("id").primaryKey(),
  projectId: serial("project_id").notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
});

export const insertNoteSchema = createInsertSchema(notes).omit({
  id: true,
  createdAt: true,
});

// Tags table
export const tags = pgTable("tags", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  color: text("color").notNull(),
  count: serial("count").default(0),
});

export const insertTagSchema = createInsertSchema(tags).omit({
  id: true,
});

// Types
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;

export type Project = typeof projects.$inferSelect;
export type InsertProject = z.infer<typeof insertProjectSchema>;

export type Note = typeof notes.$inferSelect;
export type InsertNote = z.infer<typeof insertNoteSchema>;

export type Tag = typeof tags.$inferSelect;
export type InsertTag = z.infer<typeof insertTagSchema>;

// ====================== DATABASE CONNECTION ======================
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from "ws";

neonConfig.webSocketConstructor = ws;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle({ client: pool, schema: { users, projects, notes, tags } });

// ====================== AUTHENTICATION ======================
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Express } from "express";
import session from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import connectPg from "connect-pg-simple";

declare global {
  namespace Express {
    interface User extends User {}
  }
}

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

export async function comparePasswords(supplied: string, stored: string) {
  const [hashed, salt] = stored.split(".");
  const hashedBuf = Buffer.from(hashed, "hex");
  const suppliedBuf = (await scryptAsync(supplied, salt, 64)) as Buffer;
  return timingSafeEqual(hashedBuf, suppliedBuf);
}

// ====================== STORAGE INTERFACE ======================
import { eq, and, desc } from "drizzle-orm";

export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  
  // Project methods
  getProjects(completed?: boolean): Promise<Project[]>;
  getProject(id: number): Promise<Project | undefined>;
  createProject(project: InsertProject): Promise<Project>;
  updateProject(id: number, project: Partial<InsertProject>): Promise<Project | undefined>;
  markProjectComplete(id: number, completed: boolean): Promise<Project | undefined>;
  deleteProject(id: number): Promise<boolean>;
  
  // Note methods
  getNotes(projectId: number): Promise<Note[]>;
  createNote(note: InsertNote): Promise<Note>;
  updateNote(id: number, content: string): Promise<Note | undefined>;
  deleteNote(id: number): Promise<boolean>;
  
  // Tag methods
  getTags(): Promise<Tag[]>;
  createTag(tag: InsertTag): Promise<Tag>;
  updateTagCount(name: string, increment: boolean): Promise<Tag | undefined>;
  
  sessionStore: session.SessionStore;
}

export class DatabaseStorage implements IStorage {
  sessionStore: session.SessionStore;
  
  constructor() {
    const PostgresSessionStore = connectPg(session);
    this.sessionStore = new PostgresSessionStore({
      pool,
      createTableIfMissing: true,
    });
  }
  
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(insertUser)
      .returning();
    return user;
  }

  async getProjects(completed?: boolean): Promise<Project[]> {
    if (completed === undefined) {
      return db.select().from(projects).orderBy(desc(projects.updatedAt));
    }
    return db.select().from(projects).where(eq(projects.completed, completed)).orderBy(desc(projects.updatedAt));
  }

  async getProject(id: number): Promise<Project | undefined> {
    const [project] = await db.select().from(projects).where(eq(projects.id, id));
    return project || undefined;
  }

  async createProject(insertProject: InsertProject): Promise<Project> {
    const [project] = await db
      .insert(projects)
      .values(insertProject)
      .returning();
    return project;
  }

  async updateProject(id: number, projectUpdate: Partial<InsertProject>): Promise<Project | undefined> {
    const [updatedProject] = await db
      .update(projects)
      .set({ ...projectUpdate, updatedAt: new Date() })
      .where(eq(projects.id, id))
      .returning();
    return updatedProject || undefined;
  }

  async markProjectComplete(id: number, completed: boolean): Promise<Project | undefined> {
    const [updatedProject] = await db
      .update(projects)
      .set({ completed, updatedAt: new Date() })
      .where(eq(projects.id, id))
      .returning();
    return updatedProject || undefined;
  }

  async deleteProject(id: number): Promise<boolean> {
    const result = await db
      .delete(projects)
      .where(eq(projects.id, id))
      .returning({ id: projects.id });
    return result.length > 0;
  }

  async getNotes(projectId: number): Promise<Note[]> {
    return db.select().from(notes).where(eq(notes.projectId, projectId)).orderBy(desc(notes.createdAt));
  }

  async createNote(insertNote: InsertNote): Promise<Note> {
    const [note] = await db
      .insert(notes)
      .values(insertNote)
      .returning();
    return note;
  }

  async updateNote(id: number, content: string): Promise<Note | undefined> {
    const [updatedNote] = await db
      .update(notes)
      .set({ content })
      .where(eq(notes.id, id))
      .returning();
    return updatedNote || undefined;
  }

  async deleteNote(id: number): Promise<boolean> {
    const result = await db
      .delete(notes)
      .where(eq(notes.id, id))
      .returning({ id: notes.id });
    return result.length > 0;
  }

  async getTags(): Promise<Tag[]> {
    return db.select().from(tags);
  }

  async createTag(insertTag: InsertTag): Promise<Tag> {
    const [tag] = await db
      .insert(tags)
      .values(insertTag)
      .returning();
    return tag;
  }

  async updateTagCount(name: string, increment: boolean): Promise<Tag | undefined> {
    const [tag] = await db.select().from(tags).where(eq(tags.name, name));
    if (!tag) return undefined;
    
    const newCount = increment ? tag.count + 1 : Math.max(0, tag.count - 1);
    const [updatedTag] = await db
      .update(tags)
      .set({ count: newCount })
      .where(eq(tags.id, tag.id))
      .returning();
    return updatedTag;
  }
}

export const storage = new DatabaseStorage();

// ====================== SERVER SETUP & ROUTES ======================
import express, { type Request, type Response, type NextFunction } from "express";
import { createServer, type Server } from "http";

// Authentication middleware
function isAuthenticated(req: Request, res: Response, next: NextFunction) {
  if (req.isAuthenticated()) {
    return next();
  }
  return res.status(401).json({ message: "Authentication required" });
}

export function setupAuth(app: Express) {
  const sessionSettings: session.SessionOptions = {
    secret: 'your-secret-key', // use a proper env variable in production
    resave: false,
    saveUninitialized: false,
    store: storage.sessionStore,
    cookie: {
      maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
    }
  };

  app.set("trust proxy", 1);
  app.use(session(sessionSettings));
  app.use(passport.initialize());
  app.use(passport.session());

  passport.use(
    new LocalStrategy(async (username, password, done) => {
      try {
        const user = await storage.getUserByUsername(username);
        if (!user || !(await comparePasswords(password, user.password))) {
          return done(null, false);
        } else {
          return done(null, user);
        }
      } catch (error) {
        return done(error);
      }
    }),
  );

  passport.serializeUser((user, done) => done(null, user.id));
  passport.deserializeUser(async (id: number, done) => {
    try {
      const user = await storage.getUser(id);
      done(null, user);
    } catch (error) {
      done(error);
    }
  });

  app.post("/api/register", async (req, res, next) => {
    try {
      const existingUser = await storage.getUserByUsername(req.body.username);
      if (existingUser) {
        return res.status(400).send("Username already exists");
      }

      const user = await storage.createUser({
        ...req.body,
        password: await hashPassword(req.body.password),
      });

      req.login(user, (err) => {
        if (err) return next(err);
        res.status(201).json(user);
      });
    } catch (error) {
      next(error);
    }
  });

  app.post("/api/login", passport.authenticate("local"), (req, res) => {
    res.status(200).json(req.user);
  });

  app.post("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.sendStatus(200);
    });
  });

  app.get("/api/user", (req, res) => {
    if (!req.isAuthenticated()) return res.status(401).json({ message: "Not authenticated" });
    res.json(req.user);
  });
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Set up authentication
  setupAuth(app);

  // Project routes
  app.get("/api/projects", isAuthenticated, async (req, res) => {
    try {
      const completed = req.query.completed !== undefined ? req.query.completed === 'true' : undefined;
      const projects = await storage.getProjects(completed);
      res.json(projects);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch projects" });
    }
  });

  app.get("/api/projects/:id", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const project = await storage.getProject(id);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }
      res.json(project);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch project" });
    }
  });

  app.post("/api/projects", isAuthenticated, async (req, res) => {
    try {
      const parseResult = insertProjectSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ error: parseResult.error });
      }
      
      const project = await storage.createProject(parseResult.data);
      res.status(201).json(project);
    } catch (error) {
      res.status(500).json({ error: "Failed to create project" });
    }
  });

  app.patch("/api/projects/:id", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const project = await storage.getProject(id);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      const updatedProject = await storage.updateProject(id, req.body);
      res.json(updatedProject);
    } catch (error) {
      res.status(500).json({ error: "Failed to update project" });
    }
  });

  app.patch("/api/projects/:id/complete", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const project = await storage.getProject(id);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      const completed = req.body.completed;
      const updatedProject = await storage.markProjectComplete(id, completed);
      res.json(updatedProject);
    } catch (error) {
      res.status(500).json({ error: "Failed to update project status" });
    }
  });

  app.delete("/api/projects/:id", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const project = await storage.getProject(id);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      const deleted = await storage.deleteProject(id);
      if (deleted) {
        res.status(204).send();
      } else {
        res.status(500).json({ error: "Failed to delete project" });
      }
    } catch (error) {
      res.status(500).json({ error: "Failed to delete project" });
    }
  });

  // Note routes
  app.get("/api/projects/:projectId/notes", isAuthenticated, async (req, res) => {
    try {
      const projectId = parseInt(req.params.projectId);
      const project = await storage.getProject(projectId);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      const notes = await storage.getNotes(projectId);
      res.json(notes);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch notes" });
    }
  });

  app.post("/api/notes", isAuthenticated, async (req, res) => {
    try {
      const parseResult = insertNoteSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ error: parseResult.error });
      }
      
      const project = await storage.getProject(parseResult.data.projectId);
      if (!project) {
        return res.status(404).json({ error: "Project not found" });
      }

      const note = await storage.createNote(parseResult.data);
      res.status(201).json(note);
    } catch (error) {
      res.status(500).json({ error: "Failed to create note" });
    }
  });

  app.patch("/api/notes/:id", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const content = req.body.content;
      if (!content) {
        return res.status(400).json({ error: "Content is required" });
      }

      const updatedNote = await storage.updateNote(id, content);
      if (!updatedNote) {
        return res.status(404).json({ error: "Note not found" });
      }
      
      res.json(updatedNote);
    } catch (error) {
      res.status(500).json({ error: "Failed to update note" });
    }
  });

  app.delete("/api/notes/:id", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const deleted = await storage.deleteNote(id);
      if (deleted) {
        res.status(204).send();
      } else {
        res.status(404).json({ error: "Note not found" });
      }
    } catch (error) {
      res.status(500).json({ error: "Failed to delete note" });
    }
  });

  // Tag routes
  app.get("/api/tags", isAuthenticated, async (req, res) => {
    try {
      const tags = await storage.getTags();
      res.json(tags);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch tags" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}

// ====================== REACT FRONTEND COMPONENTS ======================
import { createContext, ReactNode, useContext, useState } from "react";
import { 
  useQuery, 
  useMutation, 
  UseMutationResult, 
  QueryClientProvider, 
  QueryClient
} from "@tanstack/react-query";
import { format, formatDistanceToNow } from "date-fns";
import { Switch, Route, useLocation, Link } from "wouter";
import React from "react";
// ... other imports would go here

// --------- CLIENT TYPES ---------
interface NoteWithRelations extends Note {
  formattedCreatedAt?: string;
}

interface ProjectWithRelations extends Project {
  formattedCreatedAt?: string;
  formattedUpdatedAt?: string;
  timeAgo?: string;
}

// --------- REACT QUERY CLIENT ---------
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});

export async function apiRequest(
  method: string,
  url: string,
  body?: any
) {
  const options: RequestInit = {
    method,
    headers: {
      "Content-Type": "application/json",
    },
  };

  if (body) {
    options.body = JSON.stringify(body);
  }

  const res = await fetch(url, options);
  if (!res.ok) {
    const text = await res.text();
    try {
      const json = JSON.parse(text);
      throw new Error(json.message || json.error || `API Error: ${res.status}`);
    } catch (e) {
      throw new Error(text || `API Error: ${res.status}`);
    }
  }
  return res;
}

// --------- AUTH CONTEXT ---------
// User type - should match with server
interface User {
  id: number;
  username: string;
}

type AuthContextType = {
  user: User | null;
  isLoading: boolean;
  error: Error | null;
  loginMutation: UseMutationResult<User, Error, LoginData>;
  logoutMutation: UseMutationResult<void, Error, void>;
  registerMutation: UseMutationResult<User, Error, RegisterData>;
};

type LoginData = {
  username: string;
  password: string;
};

type RegisterData = LoginData;

export const AuthContext = createContext<AuthContextType | null>(null);
export function AuthProvider({ children }: { children: ReactNode }) {
  const { toast } = useToast();
  
  // Get currently logged in user
  const {
    data: user,
    error,
    isLoading,
  } = useQuery<User | null, Error>({
    queryKey: ["/api/user"],
    queryFn: async ({ signal }) => {
      try {
        const res = await fetch("/api/user", { signal });
        if (res.status === 401) return null;
        return await res.json();
      } catch (error) {
        // If unauthorized, just return null instead of throwing an error
        if (error instanceof Error && error.message.includes("401")) {
          return null;
        }
        throw error;
      }
    },
  });

  // Login mutation
  const loginMutation = useMutation({
    mutationFn: async (credentials: LoginData) => {
      const res = await fetch("/api/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(credentials),
      });
      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || "Login failed");
      }
      return await res.json();
    },
    onSuccess: (user: User) => {
      queryClient.setQueryData(["/api/user"], user);
      toast({
        title: "Login successful",
        description: `Welcome back, ${user.username}!`,
        variant: "default",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Login failed",
        description: error.message || "Invalid credentials",
        variant: "destructive",
      });
    },
  });

  // Register mutation
  const registerMutation = useMutation({
    mutationFn: async (credentials: RegisterData) => {
      const res = await fetch("/api/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(credentials),
      });
      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || "Registration failed");
      }
      return await res.json();
    },
    onSuccess: (user: User) => {
      queryClient.setQueryData(["/api/user"], user);
      toast({
        title: "Registration successful",
        description: `Welcome, ${user.username}!`,
        variant: "default",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Registration failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Logout mutation
  const logoutMutation = useMutation({
    mutationFn: async () => {
      const res = await fetch("/api/logout", {
        method: "POST",
      });
      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || "Logout failed");
      }
    },
    onSuccess: () => {
      queryClient.setQueryData(["/api/user"], null);
      // Invalidate all queries to force refetch after logout
      queryClient.invalidateQueries();
      toast({
        title: "Logged out",
        description: "You have been successfully logged out",
        variant: "default",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Logout failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  return (
    <AuthContext.Provider
      value={{
        user: user ?? null,
        isLoading,
        error,
        loginMutation,
        logoutMutation,
        registerMutation,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}

// --------- PROTECTED ROUTE ---------
export function ProtectedRoute({ path, component: Component }: { path: string; component: React.ComponentType }) {
  const { user, isLoading } = useAuth();
  const [_, navigate] = useLocation();

  if (isLoading) {
    return (
      <Route path={path}>
        <div className="flex items-center justify-center min-h-screen">
          <div className="h-8 w-8 animate-spin text-border">Loading...</div>
        </div>
      </Route>
    );
  }

  if (!user) {
    return (
      <Route path={path}>
        {navigate("/auth")}
      </Route>
    );
  }

  return <Route path={path} component={Component} />;
}

// --------- PROJECT NOTES COMPONENT ---------
interface ProjectNotesProps {
  projectId: number;
  projectTitle: string;
}

export function ProjectNotes({ projectId, projectTitle }: ProjectNotesProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [newNote, setNewNote] = useState("");
  const [isAddingNote, setIsAddingNote] = useState(false);
  const [editingNoteId, setEditingNoteId] = useState<number | null>(null);
  const [editingNoteContent, setEditingNoteContent] = useState("");
  const { toast } = useToast();

  // Fetch notes for the project
  const { 
    data: notes = [], 
    isLoading: notesLoading 
  } = useQuery<Note[]>({
    queryKey: ["/api/projects", projectId, "notes"],
    queryFn: async ({ queryKey }) => {
      if (!isOpen) return [];
      const response = await fetch(`/api/projects/${queryKey[1]}/notes`);
      if (!response.ok) {
        throw new Error("Failed to fetch notes");
      }
      return response.json();
    },
    enabled: isOpen
  });

  // Format notes with additional display fields
  const formattedNotes: NoteWithRelations[] = notes.map(note => {
    return {
      ...note,
      formattedCreatedAt: format(new Date(note.createdAt), "MMMM d, yyyy 'at' h:mm a")
    };
  });

  // Add note mutation
  const addNoteMutation = useMutation({
    mutationFn: async (content: string) => {
      const response = await apiRequest(
        "POST", 
        "/api/notes", 
        { projectId, content }
      );
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ 
        queryKey: ["/api/projects", projectId, "notes"] 
      });
      setNewNote("");
      setIsAddingNote(false);
      toast({
        title: "Note added",
        description: "Your note has been added successfully."
      });
    },
    onError: (error) => {
      toast({
        title: "Failed to add note",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    }
  });

  // Edit note mutation
  const editNoteMutation = useMutation({
    mutationFn: async ({ id, content }: { id: number; content: string }) => {
      const response = await apiRequest(
        "PATCH", 
        `/api/notes/${id}`, 
        { content }
      );
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ 
        queryKey: ["/api/projects", projectId, "notes"] 
      });
      setEditingNoteId(null);
      setEditingNoteContent("");
      toast({
        title: "Note updated",
        description: "Your note has been updated successfully."
      });
    },
    onError: (error) => {
      toast({
        title: "Failed to update note",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    }
  });

  // Delete note mutation
  const deleteNoteMutation = useMutation({
    mutationFn: async (id: number) => {
      await apiRequest("DELETE", `/api/notes/${id}`);
      return id;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ 
        queryKey: ["/api/projects", projectId, "notes"] 
      });
      toast({
        title: "Note deleted",
        description: "Your note has been deleted successfully."
      });
    },
    onError: (error) => {
      toast({
        title: "Failed to delete note",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    }
  });

  const handleAddNote = () => {
    if (newNote.trim()) {
      addNoteMutation.mutate(newNote.trim());
    }
  };

  const handleEditNote = (id: number, content: string) => {
    setEditingNoteId(id);
    setEditingNoteContent(content);
  };

  const handleSaveEdit = () => {
    if (editingNoteId && editingNoteContent.trim()) {
      editNoteMutation.mutate({ 
        id: editingNoteId, 
        content: editingNoteContent.trim() 
      });
    }
  };

  const handleDeleteNote = (id: number) => {
    deleteNoteMutation.mutate(id);
  };

  // Sheet component would be shown here
  // Implementation would depend on your UI component library
  return (
    <div>
      <button onClick={() => setIsOpen(true)}>Notes</button>
      {isOpen && (
        <div className="notes-panel">
          <h3>Notes for {projectTitle}</h3>
          <button onClick={() => setIsOpen(false)}>Close</button>
          
          {!isAddingNote && (
            <button onClick={() => setIsAddingNote(true)}>Add Note</button>
          )}
          
          {isAddingNote && (
            <div>
              <textarea 
                value={newNote}
                onChange={(e) => setNewNote(e.target.value)}
                placeholder="Enter your note..."
              />
              <div>
                <button 
                  onClick={() => {
                    setIsAddingNote(false);
                    setNewNote("");
                  }}
                >
                  Cancel
                </button>
                <button 
                  onClick={handleAddNote}
                  disabled={!newNote.trim() || addNoteMutation.isPending}
                >
                  {addNoteMutation.isPending ? "Saving..." : "Save"}
                </button>
              </div>
            </div>
          )}
          
          {notesLoading && <div>Loading notes...</div>}
          
          {!notesLoading && formattedNotes.length === 0 && !isAddingNote && (
            <div>No notes yet. Add your first note to track progress.</div>
          )}
          
          {!notesLoading && formattedNotes.length > 0 && (
            <div>
              {formattedNotes.map((note) => (
                <div key={note.id}>
                  {editingNoteId === note.id ? (
                    <div>
                      <textarea
                        value={editingNoteContent}
                        onChange={(e) => setEditingNoteContent(e.target.value)}
                      />
                      <div>
                        <button 
                          onClick={() => {
                            setEditingNoteId(null);
                            setEditingNoteContent("");
                          }}
                        >
                          Cancel
                        </button>
                        <button 
                          onClick={handleSaveEdit}
                          disabled={!editingNoteContent.trim() || editNoteMutation.isPending}
                        >
                          {editNoteMutation.isPending ? "Saving..." : "Save"}
                        </button>
                      </div>
                    </div>
                  ) : (
                    <>
                      <p>{note.content}</p>
                      <div>
                        <span>{note.formattedCreatedAt}</span>
                        <div>
                          <button onClick={() => handleEditNote(note.id, note.content)}>
                            Edit
                          </button>
                          <button onClick={() => handleDeleteNote(note.id)}>
                            Delete
                          </button>
                        </div>
                      </div>
                    </>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// --------- CREATE PROJECT DIALOG ---------
interface CreateSimpleProjectDialogProps {
  onSubmit: (data: { title: string; description: string }) => void;
  isLoading: boolean;
}

export function CreateSimpleProjectDialog({ onSubmit, isLoading }: CreateSimpleProjectDialogProps) {
  const [title, setTitle] = useState("");
  const [description, setDescription] = useState("");
  const [open, setOpen] = useState(false);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (title.trim()) {
      onSubmit({ title, description });
      setTitle("");
      setDescription("");
      setOpen(false);
    }
  };

  return (
    <div>
      <button onClick={() => setOpen(true)}>Add Project</button>
      {open && (
        <div className="dialog">
          <h2>Add New Project</h2>
          <p>Create a new project with a title and next steps.</p>
          <form onSubmit={handleSubmit}>
            <div>
              <label htmlFor="title">Project Title</label>
              <input
                id="title"
                placeholder="Enter project title"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                disabled={isLoading}
                required
              />
            </div>
            <div>
              <label htmlFor="description">Next Steps</label>
              <textarea
                id="description"
                placeholder="What needs to be done next?"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                disabled={isLoading}
              />
            </div>
            <div>
              <button type="submit" disabled={!title.trim() || isLoading}>
                {isLoading ? "Creating..." : "Create Project"}
              </button>
            </div>
          </form>
          <button onClick={() => setOpen(false)}>Cancel</button>
        </div>
      )}
    </div>
  );
}

// --------- PROJECT LIST COMPONENT ---------
interface SimpleProjectListProps {
  projects: ProjectWithRelations[];
  isLoading: boolean;
  onMarkComplete: (id: number, completed: boolean) => void;
  onCreateProject?: (data: { title: string; description: string }) => void;
  isCreating?: boolean;
  showCreateButton?: boolean;
}

function SimpleProjectList({ 
  projects, 
  isLoading,
  onMarkComplete,
  onCreateProject,
  isCreating = false,
  showCreateButton = true
}: SimpleProjectListProps) {
  const [searchTerm, setSearchTerm] = useState("");
  
  // Filter projects based on search term
  const filteredProjects = projects.filter(project => {
    if (searchTerm && !project.title.toLowerCase().includes(searchTerm.toLowerCase()) && 
        !project.description?.toLowerCase().includes(searchTerm.toLowerCase())) {
      return false;
    }
    return true;
  });

  // Loading skeleton UI
  if (isLoading) {
    return <div>Loading projects...</div>;
  }

  return (
    <div>
      <div>
        <h2>{projects.length > 0 ? 'Your Projects' : 'No Projects'}</h2>
        {showCreateButton && onCreateProject && (
          <CreateSimpleProjectDialog 
            onSubmit={onCreateProject} 
            isLoading={isCreating} 
          />
        )}
      </div>
      
      <div>
        <input
          placeholder="Search projects"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
      </div>
      
      {filteredProjects.length > 0 ? (
        <div>
          {filteredProjects.map(project => (
            <div key={project.id}>
              <div>
                <input 
                  type="checkbox"
                  checked={project.completed}
                  onChange={() => onMarkComplete(project.id, !project.completed)}
                />
                <div>
                  <div>
                    <div>{project.title}</div>
                    <ProjectNotes projectId={project.id} projectTitle={project.title} />
                  </div>
                  
                  {project.description && (
                    <p>{project.description}</p>
                  )}
                  
                  {project.tagName && (
                    <div>
                      <span 
                        style={{ 
                          borderColor: project.tagColor || 'currentColor',
                          color: project.tagColor || 'currentColor'
                        }}
                      >
                        {project.tagName}
                      </span>
                    </div>
                  )}
                  
                  <div>
                    <div>
                      <span>Next Step:</span>
                      <div>
                        {project.description ? (
                          <span>{project.description}</span>
                        ) : (
                          <span>No next steps defined</span>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div>
          <h3>No projects found</h3>
          <p>
            {searchTerm ? 'Try adjusting your search.' : 'Get started by creating your first project.'}
          </p>
          <button>
            Add Your First Project
          </button>
        </div>
      )}
    </div>
  );
}

// --------- HOME PAGE COMPONENT ---------
function SimpleHomePage() {
  const { toast } = useToast();
  const { logoutMutation, user } = useAuth();
  const [activeTab, setActiveTab] = useState<"active" | "completed">("active");

  // Fetch active projects
  const { 
    data: activeProjects = [], 
    isLoading: activeProjectsLoading 
  } = useQuery<Project[]>({
    queryKey: ["/api/projects", false], 
    queryFn: async ({ queryKey }) => {
      const response = await fetch(`/api/projects?completed=${queryKey[1]}`);
      if (!response.ok) {
        throw new Error("Failed to fetch projects");
      }
      return response.json();
    }
  });
  
  // Fetch completed projects
  const { 
    data: completedProjects = [], 
    isLoading: completedProjectsLoading 
  } = useQuery<Project[]>({
    queryKey: ["/api/projects", true], 
    queryFn: async ({ queryKey }) => {
      const response = await fetch(`/api/projects?completed=${queryKey[1]}`);
      if (!response.ok) {
        throw new Error("Failed to fetch projects");
      }
      return response.json();
    }
  });

  // Format active projects with additional display fields
  const formattedActiveProjects: ProjectWithRelations[] = activeProjects.map(project => {
    const createdDate = new Date(project.createdAt);
    const updatedDate = new Date(project.updatedAt);
    
    return {
      ...project,
      formattedCreatedAt: format(createdDate, "MMM d, yyyy"),
      formattedUpdatedAt: format(updatedDate, "MMM d, yyyy"),
      timeAgo: formatDistanceToNow(updatedDate, { addSuffix: true })
    };
  });

  // Format completed projects with additional display fields
  const formattedCompletedProjects: ProjectWithRelations[] = completedProjects.map(project => {
    const createdDate = new Date(project.createdAt);
    const updatedDate = new Date(project.updatedAt);
    
    return {
      ...project,
      formattedCreatedAt: format(createdDate, "MMM d, yyyy"),
      formattedUpdatedAt: format(updatedDate, "MMM d, yyyy"),
      timeAgo: formatDistanceToNow(updatedDate, { addSuffix: true })
    };
  });

  // Handle marking a project as complete
  const markCompleteMutation = useMutation({
    mutationFn: async ({ id, completed }: { id: number; completed: boolean }) => {
      const response = await apiRequest(
        "PATCH", 
        `/api/projects/${id}/complete`, 
        { completed }
      );
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/projects"] });
      toast({
        title: "Project updated",
        description: "Project status has been updated successfully."
      });
    },
    onError: (error) => {
      toast({
        title: "Failed to update project",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    }
  });

  // Handle creating a new project
  const createProjectMutation = useMutation({
    mutationFn: async (project: { title: string; description: string }) => {
      const response = await apiRequest(
        "POST",
        "/api/projects",
        project
      );
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/projects"] });
      toast({
        title: "Project created",
        description: "Your new project has been created successfully."
      });
    },
    onError: (error) => {
      toast({
        title: "Failed to create project",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    }
  });

  const handleMarkComplete = (id: number, completed: boolean) => {
    markCompleteMutation.mutate({ id, completed });
  };

  const handleCreateProject = (data: { title: string; description: string }) => {
    createProjectMutation.mutate(data);
  };

  return (
    <div>
      <div>
        <h1>Project Tracker</h1>
        <div>
          {user && (
            <div>
              Logged in as <span>{user.username}</span>
            </div>
          )}
          <button 
            onClick={() => logoutMutation.mutate()}
            disabled={logoutMutation.isPending}
          >
            Logout
          </button>
        </div>
      </div>
      
      <div>
        <div>
          <button 
            onClick={() => setActiveTab("active")}
            className={activeTab === "active" ? "active" : ""}
          >
            Active Projects
          </button>
          <button 
            onClick={() => setActiveTab("completed")}
            className={activeTab === "completed" ? "active" : ""}
          >
            Completed Projects
          </button>
        </div>
        
        {activeTab === "active" && (
          <SimpleProjectList 
            projects={formattedActiveProjects} 
            isLoading={activeProjectsLoading}
            onMarkComplete={handleMarkComplete}
            onCreateProject={handleCreateProject}
            isCreating={createProjectMutation.isPending}
          />
        )}
        
        {activeTab === "completed" && (
          <SimpleProjectList 
            projects={formattedCompletedProjects} 
            isLoading={completedProjectsLoading}
            onMarkComplete={handleMarkComplete}
            showCreateButton={false}
          />
        )}
      </div>
    </div>
  );
}

// --------- AUTH PAGE COMPONENT ---------
function AuthPage() {
  const { user, loginMutation, registerMutation } = useAuth();
  const [location, navigate] = useLocation();
  const [loginUsername, setLoginUsername] = useState("");
  const [loginPassword, setLoginPassword] = useState("");
  const [registerUsername, setRegisterUsername] = useState("");
  const [registerPassword, setRegisterPassword] = useState("");
  
  // Redirect if already logged in
  if (user) {
    navigate("/");
    return null;
  }
  
  const onLoginSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    loginMutation.mutate({
      username: loginUsername,
      password: loginPassword,
    });
  };
  
  const onRegisterSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    registerMutation.mutate({
      username: registerUsername,
      password: registerPassword,
    });
  };
  
  return (
    <div>
      <div>
        <div>
          <h2>Login</h2>
          <form onSubmit={onLoginSubmit}>
            <div>
              <label htmlFor="login-username">Username</label>
              <input
                id="login-username"
                type="text"
                value={loginUsername}
                onChange={(e) => setLoginUsername(e.target.value)}
                required
              />
            </div>
            <div>
              <label htmlFor="login-password">Password</label>
              <input
                id="login-password"
                type="password"
                value={loginPassword}
                onChange={(e) => setLoginPassword(e.target.value)}
                required
              />
            </div>
            <button
              type="submit"
              disabled={loginMutation.isPending}
            >
              {loginMutation.isPending ? "Logging in..." : "Login"}
            </button>
          </form>
        </div>
        
        <div>
          <h2>Register</h2>
          <form onSubmit={onRegisterSubmit}>
            <div>
              <label htmlFor="register-username">Username</label>
              <input
                id="register-username"
                type="text"
                value={registerUsername}
                onChange={(e) => setRegisterUsername(e.target.value)}
                required
              />
            </div>
            <div>
              <label htmlFor="register-password">Password</label>
              <input
                id="register-password"
                type="password"
                value={registerPassword}
                onChange={(e) => setRegisterPassword(e.target.value)}
                required
              />
            </div>
            <button
              type="submit"
              disabled={registerMutation.isPending}
            >
              {registerMutation.isPending ? "Creating account..." : "Register"}
            </button>
          </form>
        </div>
      </div>
    </div>
  );
}

// --------- TOAST UTILITIES ---------
// Simple toast implementation - would normally use a UI component library
interface Toast {
  id: string;
  title: string;
  description?: string;
  variant?: 'default' | 'destructive';
}

export function useToast() {
  const toast = (props: Omit<Toast, 'id'>) => {
    // In a real implementation, this would display a toast notification
    console.log(`TOAST: ${props.title} - ${props.description}`);
  };

  return { toast };
}

// --------- MAIN APP COMPONENT ---------
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <Switch>
          <ProtectedRoute path="/" component={SimpleHomePage} />
          <Route path="/auth" component={AuthPage} />
          <Route path="*">
            <div>
              <h1>404 - Not Found</h1>
              <p>The page you're looking for doesn't exist.</p>
              <Link href="/">Go home</Link>
            </div>
          </Route>
        </Switch>
      </AuthProvider>
    </QueryClientProvider>
  );
}

// ====================== SERVER ENTRY POINT ======================
import express from "express";
import path from "path";

async function startServer() {
  const app = express();
  
  // Middleware
  app.use(express.json());
  
  // Register API routes
  const server = await registerRoutes(app);
  
  // Static files
  app.use(express.static(path.join(__dirname, 'public')));
  
  // SPA fallback
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
  });
  
  // Start the server
  const PORT = process.env.PORT || 3000;
  server.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
  });
}

startServer().catch(console.error);
